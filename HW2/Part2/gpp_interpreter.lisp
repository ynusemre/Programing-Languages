; *********************************************
; *  341 Programming Languages                *
; *  Fall 2021                                *
; *  Author: Yunus Emre Geyik                 *
; *  File  : gpp_interpreter.lisp 			  *
; * 										  *
; * Syntax Analyser via interpreter for G++   * 
; *********************************************

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

; This function using for read whole_input from the file that is a option for user.
(defun read_from_file (filename)
	(let ((word-list (list )) (tokenList) (parser))
		(with-open-file (file-stream filename)
			(when file-stream
				(loop for line = (read-line file-stream nil)
					while line 
						do 
                        (setq tokenList (lexer (concatenate 'string line " ")))
                        (setq parser (parser tokenList))
                        (when (not (equal parser "[404]"))
                            (format t "Syntax OK.~%")
                            (format t "Result:~A~%~%" parser) 
                        )
                )
				(close file-stream)
			))))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

; In this function, function checking the considered char is in the alphabet
(defun isAlphabetical(alpha)		
	(if (not(or (and (> (char-int alpha) 96) (< (char-int alpha) 123))
			(and (> (char-int alpha) 64) (< (char-int alpha) 91))
		))
		nil
		t
	))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

;This function converts list to string.
(defun listToString (list)
    (let ( (tempList (list )))
        (loop for i from 0 to (-( length list) 1)
            do
            (setq tempList (append tempList (list (coerce  (nth i list ) 'string))))             
        )
        tempList
    ))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

(defun isDigit(digit)		; Digit Checking Function
	(if (not(and (> (char-int digit) 47) (< (char-int digit) 58)))
		nil
		t))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

; method that checks for parentheses
(defun paranthes_error_check (stringList)
    (let ((par_num 0))
        (loop for i from 0 to (- (length stringList) 1)
            do
            (if (or (equal (nth i stringList) "(") (equal (nth i stringList) "'("))
                (incf par_num 1)
            )
            (when (equal (nth i stringList) ")")
                (if (= par_num 0)
                    (return-from paranthes_error_check 0)
                )
                (decf par_num 1)
            )
            (if (and (equal par_num 0) (< i (- (length stringList) 1)))
                (return-from paranthes_error_check 0)
            )
        )
        (if (equal par_num 0)

            (return-from paranthes_error_check t)
        nil
        )))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

; Lexer Part. 
(defun lexer (whole_input)
	(let ((initialList (list )) (tokenList (list )) (wholeList (list )) (colorValue 0) (color 0) (colorIdentifier 0)(colorInner 0) (check 0) (checkVal 0) (interpreterList (list )) (intrList (list )))
        
        (setq whole_input (string-downcase whole_input))
        ;to holds operators in list for some controls.
		(setq list (list #\+  #\- #\/ #\* #\( #\) #\" #\, #\space ) )

		 ;for checking until the end of the string
		(loop for i from 0 to (-(length whole_input)1) 
			do
		
			(setq sign (char whole_input i)) 
		
			;in this part the program determines what the operator is.
			(when (and(equal sign #\;) (equal (char whole_input (+ i 1)) #\;))
                (setq intrList (append intrList (list sign)))
                (setq intrList (append intrList (list (char whole_input (+ i 1)))))
                (setq interpreterList (append interpreterList (list intrList)))
                
                (setq tokenList (append tokenList (list "COMMENT")))
				(setq check 1)
			)
			(when (equal sign #\+) 
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_PLUS")))
				(setq check 1)
			)
			(when (equal sign #\-) 
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_MINUS")))
				(setq check 1)
			
			)
			(when (equal sign #\/) 
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_DIV")))
				(setq check 1)
			
			)
			(when (and(equal sign #\*)(< (+ i ) (length whole_input) )(not (equal (char whole_input (+ i 1))  #\*))(not (equal (char whole_input (- i 1))  #\*)))
               (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_MULT")))
				(setq check 1)
			
			)
			(when (equal sign #\( )  
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_OP")))
				(setq check 1)
			)
			(when (equal sign #\) )  
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_CP")))
				(setq check 1)
			)
			(when (and (equal sign #\*) (< (+ i 1) (length whole_input) )(equal (char whole_input (+ i 1))  #\*)) 
               (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_DBLMULT")))
				(setq check 1)
			
			)
            (when (and (equal sign #\') (< (+ i 1) (length whole_input) )(equal (char whole_input (+ i 1))  #\()) 
               (setq intrList (append intrList (list sign)))
               (setq intrList (append intrList (list (char whole_input (+ i 1)))))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "OP_LIST")))
				(setq check 1)
                (setq i (+ i 1))
			
			)
			(when (and (equal sign #\" ) )
				( cond ((equal color 0) 
                    (setq intrList (append intrList (list sign)))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "OP_OC")))
					(setq color 1))
					( 
                        (setq intrList (append intrList (list sign)))
                        (setq interpreterList (append interpreterList (list intrList)))
                        (setq intrList nil)
                        (setq tokenList (append tokenList (list "OP_CC")))
					    (setq color 0))

					)
					(setq check 1)
			)	
			(when (equal sign #\, )  
                (setq intrList (append intrList (list sign)))
                (setq interpreterList (append interpreterList (list intrList)))
                (setq intrList nil)
                (setq tokenList (append tokenList (list "COMMA")))
				(setq check 1)
			)
			;in this part the program determines what the value is.
			(when (equal (isDigit sign) t)
					; identify 0 as value.
					(when (and (equal sign #\0) (< (+ i 1) (length whole_input) )(equal (isDigit (char whole_input (+ i 1)) ) nil ) (equal (isDigit (char whole_input (- i 1)) ) nil ))
                        (setq intrList (append intrList (list sign)))
                        (setq interpreterList (append interpreterList (list intrList)))
                        (setq intrList nil)
                        (setq tokenList (append tokenList (list "VALUE")))
						(setq check 1)
					)
					;identify the start of value.	
					(when (and (not (equal sign #\0)) (equal (isDigit (char whole_input (- i 1)) ) nil )(equal (isAlphabetical (char whole_input (- i 1)) ) nil ))
						(setq colorValue 1)
						(setq check 1)

					)
					;to specify not to start with zero.
					(when (and  (equal colorValue 1 ) (< (+ i 1) (length whole_input) )(equal (isDigit (char whole_input (+ i 1)) ) nil ))
                        (setq intrList (append intrList (list sign)))
                        (setq interpreterList (append interpreterList (list intrList)))
                        (setq intrList nil)
                        (setq tokenList (append tokenList (list "VALUE")))
						(setq colorValue 0)
						(setq check 1)
					)	
					(when (equal colorValue 1)
                        (setq intrList (append intrList (list sign)))
						(setq check 1)
					)			
			)
			;I determine the first letters of the keywords first, then I write the possibility of the following and get the keyword.
			; Keyword and.
			(when (and(equal sign #\a )  (< (+ i 3) (length whole_input) )(equal (char whole_input (+ i 1)) #\n )(equal (char whole_input (+ i 2)) #\d )(not (equal (position (char whole_input (+ i 3) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_AND")))
					(setq colorIdentifier 1)
					(setq i (+ i 2))
					(setq check 1)
			)
			; Keyword or.
			(when (and(equal sign #\o )  (< (+ i 2) (length whole_input) )(equal (char whole_input (+ i 1)) #\r )(not (equal (position (char whole_input (+ i 2) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_OR")))
					(setq colorIdentifier 1)
					(setq i (+ i 1))
					(setq check 1)
			)
			; Keyword not.
			(when (and(equal sign #\n )  (< (+ i 3) (length whole_input) )(equal (char whole_input (+ i 1)) #\o )(equal (char whole_input (+ i 2)) #\t )(not (equal (position (char whole_input (+ i 3) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_NOT")))
					(setq colorIdentifier 1)
					(setq i (+ i 2))
					(setq check 1)
			)
			; Keyword equal.
			(when (and(equal sign #\e ) (< (+ i 5) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 5)) "qual") (not (equal (position (char whole_input (+ i 5) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_EQUAL")))
					(setq colorIdentifier 1)
					(setq i (+ i 4))
					(setq check 1)
			)
			; Keyword less.
			(when (and(equal sign #\l )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "ess") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_LESS")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
            ; Keyword exit
            (when (and(equal sign #\e )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "xit") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_EXIT")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
			; Keyword nil.
			(when (and(equal sign #\n )  (< (+ i 3) (length whole_input) )(equal (char whole_input (+ i 1)) #\i )(equal (char whole_input (+ i 2)) #\l )(not (equal (position (char whole_input (+ i 3) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_NIL")))
					(setq colorIdentifier 1)
					(setq i (+ i 2))
					(setq check 1)
			)
			; Keyword list.
			(when (and(equal sign #\l )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "ist") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_LIST")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
			; Keyword append.
			(when (and(equal sign #\a )  (< (+ i 6) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 6)) "ppend") (not (equal (position (char whole_input (+ i 6) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))(list (char whole_input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_APPEND")))
					(setq colorIdentifier 1)
					(setq i (+ i 5))
					(setq check 1)
			)
			; Keyword concat.
			(when (and(equal sign #\c )  (< (+ i 6) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 6)) "oncat") (not (equal (position (char whole_input (+ i 6) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))(list (char whole_input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_CONCAT")))
					(setq colorIdentifier 1)
					(setq i (+ i 5))
					(setq check 1)
			)
			; Keyword set.
			(when (and(equal sign #\s )  (< (+ i 3) (length whole_input) )(equal (char whole_input (+ i 1)) #\e )(equal (char whole_input (+ i 2)) #\t )(not (equal (position (char whole_input (+ i 3) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_SET")))
					(setq colorIdentifier 1)
					(setq i (+ i 2))
					(setq check 1)
					
			)
			; Keyword deffun.
			(when (and(equal sign #\d )  (< (+ i 6) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 6)) "effun") (not (equal (position (char whole_input (+ i 6) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))(list (char whole_input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_DEFFUN")))
					(setq colorIdentifier 1)
					(setq i (+ i 6))
					(setq check 1)
			)
            ; Keyword defvar
            (when (and(equal sign #\d )  (< (+ i 6) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 6)) "efvar") (not (equal (position (char whole_input (+ i 6) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))(list (char whole_input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_DEFVAR")))
					(setq colorIdentifier 1)
					(setq i (+ i 6))
					(setq check 1)
			)
			; Keyword for.
			(when (and(equal sign #\f )  (< (+ i 3) (length whole_input) )(equal (char whole_input (+ i 1)) #\o )(equal (char whole_input (+ i 2)) #\r )(not (equal (position (char whole_input (+ i 3) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_FOR")))
					(setq colorIdentifier 1)
					(setq i (+ i 2))
					(setq check 1)
			)
			; Keyword if.
			(when (and(equal sign #\i )  (< (+ i 2) (length whole_input) )(equal (char whole_input (+ i 1)) #\f )(not (equal (position (char whole_input (+ i 2) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_IF")))
					(setq colorIdentifier 1)
					(setq i (+ i 1))
					(setq check 1)
			)
			; Keyword exit.
			(when (and(equal sign #\e )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "xit") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_EXIT")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
			; Keyword load.
			(when (and(equal sign #\l ) (< (+ i 4) (length whole_input) ) (equal (subseq whole_input (+ i 1) (+ i 4)) "oad") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_LOAD")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
			; Keyword disp.
			(when (and(equal sign #\d )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "isp") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_DISP")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
			; Keyword true.
			(when (and(equal sign #\t )  (< (+ i 4) (length whole_input) )(equal (subseq whole_input (+ i 1) (+ i 4)) "rue") (not (equal (position (char whole_input (+ i 4) ) list )nil )))
                    (setq intrList (append intrList (list sign)(list (char whole_input (+ i 1)) )))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_TRUE")))
					(setq colorIdentifier 1)
					(setq i (+ i 3))
					(setq check 1)
			)
            ; Keyword while
            (when (and(equal sign #\w ) (< (+ i 5) (length whole_input) ) (equal (subseq whole_input (+ i 1) (+ i 5)) "hile") (not (equal (position (char whole_input (+ i 5) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_WHILE")))
					(setq colorIdentifier 1)
					(setq i (+ i 4))
					(setq check 1)
			)
			; Keyword false.
			(when (and(equal sign #\f ) (< (+ i 5) (length whole_input) ) (equal (subseq whole_input (+ i 1) (+ i 5)) "alse") (not (equal (position (char whole_input (+ i 5) ) list )nil )))
                    (setq intrList (append intrList (list sign) (list (char whole_input (+ i 1)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 2)))(list (char whole_input (+ i 3)))))
                    (setq intrList (append intrList (list (char whole_input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq intrList nil)
                    (setq tokenList (append tokenList (list "KW_FALSE")))
					(setq colorIdentifier 1)
					(setq i (+ i 4))
					(setq check 1)
			)
			;This condition specify identifiers.
			(when (and (equal colorIdentifier 0)(or(equal (isAlphabetical sign) t ) (equal colorInner 1)))
				(setq check 1) 
                (setq intrList (append intrList (list sign)))
				(when  (equal (isDigit(char whole_input (+ i 1))) t) ;identifier can include digits.
						(setq colorInner 1)
						(setq check 1)

				)
				;This condition specify end of identifier.
				(when  (not (equal (position (char whole_input (+ i 1) ) list )nil ))
                    (setq interpreterList (append interpreterList (list intrList)))
                    (setq tokenList (append tokenList (list "IDENTIFIER")))
                    (setq intrList nil)
				    (setq colorInner 0)
                     
					(setq check 1)
				)
			)
			;prevent given space ,newline, ; , tab expression for error checking.  
			(when (or(equal sign #\space )(equal sign #\newline)(equal sign #\*)(equal sign #\;)(equal sign #\tab))
				(Setq check 1)
			) 
			
			(when (equal check 0)
					(format t "SYNTAX_ERROR ~a cannot be tokenized!" sign)(terpri)
				(return nil)
			)
			(setq colorIdentifier 0)
			(setq check 0)		
		)
        (setq interpreterList (listToString interpreterList))
        (loop for n from 0 to ( - (list-length interpreterList) 1 )
			do
                (setq initialList (append initialList (list (nth n interpreterList))(list (nth n tokenList)) ))
                (setq wholeList (append wholeList (list initialList)))
                (setq initialList nil)
				
		)	
        wholeList	
    ))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

;In this part code doing syntax analiysis.
(defun parser (whole_input)
    (let ((discover 0)(colorAfter 1)(colorError 1) (i 0  )(color 0) (sum 0 )(check 0)(keep 0)(errordiscover 1)(logic t)(value1 ) (value2 )(check nil)(result )(lst (list ))(tempList (list )))
        (Setq errordiscover (paranthes_error_check whole_input))
        (Setq discover 0)
        ; In this part code doing syntax analiysis
        (when (equal  errordiscover 0)  
			; (+ EXPI EXPI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "+"))
                (let ( (sum 0)(colorError 1 ) (colorAfter 1)(keep 0 )(check 0)(color 0)(res 0)) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (Setq colorError 1)
                        (when  (and(equal (nth  1 (nth i whole_input) ) "VALUE") (equal check 0))
                            (setq colorError 0)
                            (setq sum (+ sum (parse-integer (nth  0 (nth i whole_input) ))))
                        )
                        (when (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0)
                            (Setq colorAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0)
                            (Setq colorAfter 1)
                        ) 
                        (when (and (equal colorAfter 1 ) (equal (nth  1 (nth i whole_input) ) "VALUE"))
                            (setq colorError 0)
                        )
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                            (Setq colorError 0)
                        )
                        (when  (and (equal color  0) (equal check 1 )) 
                            (setq check 0)
                            (setq colorError 0)
                            (setq res (parser ( subseq whole_input keep (+ i 1))))
                            (when (typep res 'integer)
                                (Setq sum (+ sum res))
                                (setq colorError 0)
                            ) 
                            (when (not (typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )  
                            (Setq colorAfter 1)     
                        ) 
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )    
                    ) 
                    (setq result sum)
                ) 
                (setq discover 1)    
            )
            ;(* EXPI EXPI)                           
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "*"))
                (let ( (color 0)(check 0)  (mult 1 ) (colorError 1 ) (colorAfter 1)(res 0)(keep 0)) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (Setq colorError 1)
                        (when   (and (equal (nth  1 (nth i whole_input) ) "VALUE")(equal check 0)) 
                            (setq mult (* mult (parse-integer (nth  0 (nth i whole_input) ))))
                            (Setq colorError 0)
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (Setq colorError 0)
                            (setq check 1)
                            (setq colorAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (Setq colorError 0)
                            (Setq colorAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                            (Setq colorError 0)
                        )
                        (when (and (equal colorAfter 1 ) (equal (nth  1 (nth i whole_input) ) "VALUE"))
                            (setq colorError 0)
                        )
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq res (parser ( subseq whole_input keep (+ i 1))))
                            (setq colorError 0)
                            (when (typep res 'integer)
                                (setq colorError 0)
                                (Setq mult (* mult res ))
                            )
                            (when (not (typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                ( return-from parser "error")
                            )       
                        )
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )         
                    )
                    (setq result mult)
                )
                (setq discover 1)                             
            )
            ;(- EXPI EXPI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "-")) 
                (let ( (color 0)(start 0) (colorRec 0  )(important 0) (diff 0 )(check 0)(res 0)(keep 0))
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when   (and (equal (nth  1 (nth i whole_input) ) "VALUE")(equal check 0)) 
                            (when (equal start 0)
                                (setq diff (- (parse-integer (nth  0 (nth i whole_input) )) diff ))
                                (setq important 1)
                                (setq colorError 0)
                            ) 
                            (when (equal start 1)
                                (setq diff (- diff (parse-integer (nth  0 (nth i whole_input) ))))
                                (setq start 0)
                                (setq important 0)
                                (setq colorError 0)
                            )   
                            (setq start 1) 
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq start 1)  
                            (setq colorError 0)
                            (setq colorAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0)
                            (setq colorAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                            (Setq colorError 0)
                        )
                        (when (and (equal colorAfter 1 ) (equal (nth  1 (nth i whole_input) ) "VALUE"))
                            (setq colorError 0)
                        )
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq colorError 0)
                            (setq res  (parser ( subseq whole_input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when (equal important 0)
                                    (Setq diff (- res diff))
                                )
                                (when (equal important 1)
                                    (Setq diff (- diff res))
                                )  
                            ) 
                            (when (not (typep res'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )         
                        ) 
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )      
                    ) 
                    (setq result diff) 
                )
                (Setq discover 1) 
                result                     
            )
            ;(/ EXPI EXPI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "/"))
                (let ( (color 0)(start 0) (colorRec 0  )(important 0) (div 1 )(check 0)(res 0)(keep 0)) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when   (and (equal (nth  1 (nth i whole_input) ) "VALUE")(equal check 0)) 
                            (when (equal start 0)
                                (setq div (/ (parse-integer (nth  0 (nth i whole_input) )) div ))
                                (setq important 1)
                                (setq colorError 0)
                            ) 
                            (when (equal start 1)
                                (setq div (/ div (parse-integer (nth  0 (nth i whole_input) ))))
                                (setq start 0)
                                (setq important 0)
                                (setq colorError 0)
                            )  
                            (setq start 1) 
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq start 1) 
                            (setq colorError 0)
                            (setq colorAfter 0) 
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0)
                            (setq colorAfter 1)
                            
                        )
                        (when  (equal (nth  0 (nth i whole_input) ) ")" )
                            (setq colorError 0)
                            
                        ) 
                        (when (and (equal colorAfter 1 ) (equal (nth  1 (nth i whole_input) ) "VALUE"))
                            (setq colorError 0)
                        ) 
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq colorError 0)
                            (setq res (parser ( subseq whole_input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when (equal important 0)
                                    (Setq div (/ res div))
                                )
                                (when (equal important 1)
                                    (Setq div (/ div res))
                                )
                                (setq colorError 0)    
                            )
                            (when (not (typep res'integer))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )         

                        )       
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )                
                      
                    )
                    (setq result div)     
                )
                (setq discover 1)            
            )
            ; (Id EXPLISTI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "IDENTIFIER")) 
                (let ( (color 0)(identifier 0)(check 0) (index 0) (mult 1 ) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(j 0)(num 0)) 
                    (Setq identifier (nth 0  (nth (+ i 1) whole_input) ))
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1)
                            (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                    (when (equal color 0)
                                        (setq keep i)
                                    )
                                    (Setq index i)
                                    (setq colorError 0)
                                    (setq color ( + color 1 )) 
                                    (setq check 1)
                                    (setq colorAfter 0)
                                    (setq first 1)  
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq colorError 0)
                                    (setq color (- color 1)) 
                                    (setq colorAfter 1)   
                            ) 
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                            )
                            (when  (and (equal color  0)(equal check 1 ))
                                    (Setq check 0)
                                    (Setq colorError 0)
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (setq num (+ num 1))
                                    (when (typep res 'CONS)
                                            (terpri)
                                            (format t "~a :~a "  identifier res) 
                                        
                                    )
                                    (when  (not (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                        
                                    )
                            )
                            (when (and (equal colorError 1)( equal colorAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            ) 
                            (when (and ( not (equal num 1))( not (equal num 0))) 
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )         
                    )
                    (setq result res) 
                )
                (setq discover 1)    
            )
            ; (and EXPB EXPB)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "and"))
                (let ( (color 0)(logic t)(check 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0))  
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_TRUE")(equal check 0))
                            (setq logic (and logic t))
                            (setq colorError 0 )
                        )
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_FALSE")(equal check 0))
                            (setq logic (and logic nil))
                            (setq colorError 0 )
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0 )
                            (setq colorAfter 0 )
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0 )
                            (setq colorAfter 1 )
                            
                        )
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                        ) 
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (Setq colorError 0)
                            (Setq res (parser ( subseq whole_input keep (+ i 1)) ))
                            (when (typep res 'BOOLEAN)
                                (setq logic (and logic res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")            
                            )
                            (Setq colorError 0)    
                        )
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )   

                    )
                    (setq result logic)
                )           
                (Setq discover 1)
            )
            ; (or EXPB EXPB)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "or"))
                (let ( (color 0)(logic nil)(check 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0))   
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_TRUE")(equal check 0))
                            (setq logic (or logic t))
                            (setq colorError 0)
                        )
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_FALSE")(equal check 0))
                            (setq logic (or logic nil))
                            (setq colorError 0)
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0)
                            (setq colorAfter 0)
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0)
                            (setq colorAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                        ) 
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq colorError 0)
                            (Setq res (parser ( subseq whole_input keep (+ i 1)) ))
                            (when (typep res 'BOOLEAN)
                                (setq logic (or logic res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")           
                            )
                            (setq colorError 0)    
                        )
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )  
                    )
                    (setq result logic)
                )
                (setq discover 1)          
            )
            ; (not EXPB)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "not"))
                (let ( (color 0)(logic nil)(check 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(num 0)) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_TRUE")(equal check 0))
                            (setq logic t)
                            (setq num (+ num 1))
                            (setq colorError 0) 
                        )
                        (when  (and (equal (nth  1 (nth i whole_input) ) "KW_FALSE")(equal check 0))
                            (setq logic nil)
                            (setq num (+ num 1))
                            (setq colorError 0) 
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0) 
                            (setq colorAfter 0) 
                     
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0) 
                            (setq colorAfter 1) 
                            
                        )
                         (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                        )  
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq colorError 0) 
                            (setq num (+ num 1))
                            (setq res (parser ( subseq whole_input keep (+ i 1))))
                            (when (typep res 'BOOLEAN)
                                (setq logic (not res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")            
                            )
                            (setq colorError 0)    
                        )
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )
                        (when (and ( not (equal num 1))( not (equal num 0))) 
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )       

                    ) 
                    (setq result logic)      
                )
                (setq discover 1) 
            )
            ; (equal  EXPB EXPB) and (equal EXPI EXPI)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "equal"))
                (let ( (color 0)(logic nil)(check 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(num 0)(value1 nil)(value2 nil))  
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when  (and (or (equal (nth  1 (nth i whole_input) ) "VALUE") (equal (nth  1 (nth i whole_input) ) "KW_FALSE") (equal (nth  1 (nth i whole_input) ) "KW_TRUE"))(not (equal value1 nil))(equal value2 nil)(equal check 0))
                            (when (equal (nth  1 (nth i whole_input) ) "VALUE")
                                (setq value2 (parse-integer (nth  0 (nth i whole_input) )))
                                (setq colorError 0 )
                            ) 
                            (when (equal (nth  1 (nth i whole_input) ) "KW_FALSE")
                                (setq value2 nil )
                                (setq colorError 0 )
                            
                            )
                            (when (equal (nth  1 (nth i whole_input) ) "KW_TRUE")
                                (setq value2 t )
                                (setq colorError 0 )
                            )      
                        )
                        (when  (and  (or (equal (nth  1 (nth i whole_input) ) "VALUE") (equal (nth  1 (nth i whole_input) ) "KW_FALSE") (equal (nth  1 (nth i whole_input) ) "KW_TRUE"))(equal value1 nil)(equal check 0) )
                            (when (equal (nth  1 (nth i whole_input) ) "VALUE")
                                (setq value1 (parse-integer (nth  0 (nth i whole_input) )))
                                (setq colorError 0 )
                            ) 
                            (when (equal (nth  1 (nth i whole_input) ) "KW_FALSE")
                                (setq value1 nil )
                                (setq colorError 0 )
                            
                            )
                            (when (equal (nth  1 (nth i whole_input) ) "KW_TRUE")
                                (setq value1 t )
                                (setq colorError 0 )
                            
                            )      
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0 )
                            (setq colorAfter 0 )
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0 )
                            (setq colorAfter 0 )
                            
                        ) 
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                        )
                        (when  (and (not (equal value1 nil))(not (equal value2 nil)))
                            (when (and (not (equal (type-of value1 )(type-of value2)))(not (equal (integerp value1 )(integerp value2))))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )
                            (setq logic (equal value1 value2))
                        ) 
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq colorError 0)
                            (setq res  (parser ( subseq whole_input keep (+ i 1))))
                            (when (or (typep res 'BOOLEAN)(typep res 'integer))
                                (when   (and (not(equal value1 nil))(equal value2 nil))
                                   (setq value2  res )
                                   (when (or (not (typep value2 'NULL)) (not (typep value1 'NULL)))
                                        (when (and (not (equal (type-of value1 )(type-of value2)))(not (equal (integerp value1 )(integerp value2))))
                                            (print "SYNTAX_ERROR Expression not recognized  ")
                                             ( return-from parser "error")
                                        )
                                   )       
                                )
                                (when   (equal value1 nil)
                                    (setq value1 res)
                                )
                                
                            )
                            (when (and (not (typep res 'BOOLEAN))(not(typep res 'integer)))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error") 
                            )      
                        )
                       
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )
                        (setq result logic)     
                    )
                )    
                (setq discover 1) 
            )
            ;( VALUES )    
            (when (equal (nth  0 (nth i whole_input) ) "'(" )
                (let ( (lst (list ))(colorError 1) )   
                    (loop for i from 1 to (-( length whole_input ) 1)
                        do  
                            (setq colorError 1)
                            (when   (equal (nth  1 (nth i whole_input) ) "VALUE" )
                                (setq res (nth  0 (nth i whole_input) ))
                                (Setq lst (append lst (list (parse-integer res ))))
                                (setq colorError 0)
                            )
                            (when  (equal (nth  0 (nth i whole_input) )")")
                                (setq colorError 0)
                            )
                            (when (equal colorError 1)
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )       
                     )  
                     (Setq result lst)
                )
                (setq discover 1)     
            )
            ; ( list VALUES ) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(")(equal (nth  1 (nth (+ i 1) whole_input) ) "KW_LIST") )
                (let ( (lst (list ))(colorError 1) )   
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1)
                            (when   (equal (nth  1 (nth i whole_input) ) "VALUE" )
                                (setq res (nth  0 (nth i whole_input) ))
                                (Setq lst (append lst (list (parse-integer res ))))
                                (setq colorError 0)
                            )
                            (when  (equal (nth  0 (nth i whole_input) )")")
                                (setq colorError 0)
                            )
                            (when (equal colorError 1)
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )       
                     )  
                     (Setq result lst)
                )
                (setq discover 1)     
            )
            ; (concat EXPLISTI EXPLISTI)   
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "concat"))
                (let ( (color 0)(check 0)(start 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0))   
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1)
                            (when  (equal (nth  0 (nth i whole_input) ) "'(")
                                (when (equal color 0)
                                    (setq keep i)
                                )
                                (setq color ( + color 1 )) 
                                (setq check 1)
                                (setq start 1)
                                (setq colorError 0 )
                                (setq colorAfter 0 )   
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq color (- color 1))
                                    (setq colorError 0 ) 
                                    (setq colorAfter 1 )     
                            )
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                            )  
                            (when  (and (equal color  0)(equal check 1 ))
                                (Setq check 0)
                                (setq colorError 0)
                                (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                (when (typep res 'CONS)
                                    (Setq lst ( concatenate 'list lst  res))
                                )
                                (when (not (typep res 'CONS))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )       
                            )
                            (when (and (equal colorError 1)( equal colorAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )    
                    )
                    (setq result lst) 
                )
                (setq discover 1) 
            )
            ; (append EXPI EXPLISTI)   
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "append"))
                (let (  (expiFirst 0)(colorExpi 0)(color 0)(check 0)(start 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(expi 0)(num 0))   
                    (when (equal (nth  1 (nth 2 whole_input) ) "VALUE")
                        (setq colorError 0)
                        (Setq start 1)
                        (setq expiFirst 1)
                        (setq colorExpi 1)
                        (Setq lst (append lst (list (parse-integer (nth  0 (nth 2 whole_input) )))))
                    )
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1 )
                            (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                    (when (equal color 0)
                                        (setq keep i)
                                    )
                                    (setq color ( + color 1 )) 
                                    (setq check 1)
                                    (setq start 1) 
                                    (setq colorError 0)
                                    (setq colorAfter 0)  
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq color (- color 1))
                                    (setq colorError 0) 
                                    (setq colorAfter 1)     
                            )
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                            )   
                            (when  (and (equal color  0)(equal check 1 ))
                                    (Setq check 0)
                                    (setq colorError 0)
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (setq num (+ num 1) )
                                    (when (and (not (integerp res) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (equal expiFirst 0 )
                                        (when (integerp res)
                                            (Setq lst (append lst (list res)))
                                            (Setq expiFirst 1) 
                                        )    
                                    )
                                    (when (equal expiFirst 1 )
                                        (when  (typep res 'CONS)
                                            (Setq lst ( concatenate 'list lst  res))
                                        )
                                    )
                                    (setq colorError 0)
                                   
                            )
                            (when (and (not (equal  num 0))(equal expiFirst 0))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            
                            )
                            (when (and (equal colorError 1)( equal colorAfter 1)(equal start 0))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )     
                    )
                    (setq result lst) 
                )
                (setq discover 1)     
            )
            ; (set Id EXPI)  and  (defvar Id EXPI)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (or (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_SET")(equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_DEFVAR")) (equal (nth 1  (nth (+ i 2) whole_input)  ) "IDENTIFIER")) 
                (let ( (color 0)(check 0)(start 0) (colorError 1 ) (colorAfter 1)(res nil)(j 0) (keep 0)(num 0))
                    (Setq identifier (nth 0  (nth (+ i 2) whole_input) ))
                    (Setq j 0)
                    (when (equal (nth 0  (nth (+ i 3) whole_input)  ) "(")
                        (Setq  color ( + color 1 )) 
                        (setq keep (+ i 3))
                        (setq colorError 0)
                        (setq colorAfter 0)
                        (setq check 1)
                        (loop for i from 4 to (-( length whole_input ) 1)
                            do
                                (setq colorError 1)
                                (when  (equal (nth  0 (nth i whole_input) ) "(")
                                        (setq color ( + color 1 )) 
                                        (setq colorError 0)
                                        (setq colorAfter 0)
                                )
                                (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                        (setq color (- color 1)) 
                                        (setq colorError 0)
                                        (setq colorAfter 1)   
                                ) 
                                (when (equal (nth  0 (nth i whole_input) ) ")") 
                                    (Setq colorError 0)
                                ) 
                                (when  (and (equal color  0)(equal check 1 ))
                                        (setq colorError 0)
                                        (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                        (when ( not  (typep res 'integer))
                                            (print "SYNTAX_ERROR Expression not recognized ")
                                            (return-from parser nil)
                                        )
                                        (when (typep res 'integer)
                                            (terpri)
                                            (format t "~a :~d "  identifier res) 
                                        )
                                        (setq num (+ num 1) )  
                                )
                               
                                (when (and (equal colorError 1)( equal colorAfter 1)(equal start 0))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )
                                (when (and (not (equal num 0))(not(equal num 1)))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )     
                        ) 
                        
                    )
                    (when (equal (nth 1  (nth (+ i 3) whole_input)  ) "VALUE")  
                        (setq res (nth 0  (nth (+ i 3) whole_input)))
                        (Setq colorError 0)
                        (setq num (+ num 1))
                        (format t "~a :~d "  identifier res) 
                    )
                    (when (and ( not(equal (nth 0  (nth (+ i 3) whole_input)  ) "(") )(not (equal (length whole_input )5 ) ))
                        (print "SYNTAX_ERROR Expression not recognized ")
                         ( return-from parser "error")
                    )   
                    (when (equal colorError 1)
                        (print "SYNTAX_ERROR Expression not recognized ")
                         ( return-from parser "error")
                    ) 
                    (setq result res) 
                )
                (setq discover 1)      
            )
            ; (if EXPB EXPLISTI) and  (if EXPB EXPLISTI EXPLISTI)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "if"))
                (let ((indexExpb 2)(indexExplist 3)(tempList(list ))(color 0)(check 0)(start 0)(occuring 0)(entered 0) (colorError 1 ) (colorAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) ) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1 )
                            (when (and  (or (equal  (nth  1 (nth i whole_input))  "KW_TRUE" )(equal  (nth  1 (nth i whole_input))  "KW_FALSE") )(equal check 0))
                                (when (equal  (nth  1 (nth i whole_input))  "KW_TRUE" )
                                    (Setq select t)
                                )
                                (when (equal  (nth  1 (nth i whole_input))  "KW_FALSE" )
                                    (Setq select nil)
                                )
                                (setq colorError 0)
                                (setq hold 1)
                            ) 
                            (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                    (when (equal color 0)
                                        (setq keep i)
                                    )
                                    (setq colorError 0 ) 
                                    (setq color ( + color 1 )) 
                                    (setq check 1)
                                    (setq start 1)
                                    (setq colorAfter 0 )   
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq color (- color 1))
                                    (setq colorAfter 1 )
                                    (setq colorError 0 )
                                        
                            )
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                            )  
                            (when  (and (equal color  0)(equal check 1 ))
                                    (setq colorError 0)
                                    (Setq check 0)
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (when (and (not (typep res 'boolean ) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                        (return-from parser "error")
                                    )
                                    (when (typep res 'boolean)
                                        (when (equal res t )
                                            (Setq occuring 1)
                                        
                                        )
                                        (when (equal res nil )
                                            (Setq occuring 0)
                                        
                                        )
                                        (Setq entered 1)

                                    )
                                    (setq num (+ num 1))
                                    (when (and (equal hold 0)(not (equal num 3))(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (and (equal hold 1)(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )     
                                    (when  (and (typep res 'list) (not (equal res nil))) 
                                        (Setq tempList (append tempList (list res)))
                                        (when (equal hold 0 )
                                            (when (equal occuring 1 )
                                                (when (not (equal (list-length tempList) 0))
                                                    (setq result (nth 0 tempList))
                                                )
                                                (when (equal (list-length tempList) 0)
                                                    (setq result res)
                                                )       
                                                
                                            )
                                            (when (equal occuring 0 )
                                                (when (not (equal (list-length tempList) 0))
                                                    (setq result (nth 1 tempList))
                                                )
                                                (when (equal (list-length tempList  )0)
                                                    (setq result nil)
                                                )       
                                                    
                                            )
                                            (setq indexExplist keep)
                                        )
                                        (when (equal hold 1 )
                                            (when (equal select t)
                                                (setq result (nth 0 tempList))
                                            )
                                            (when (equal select nil)
                                                (setq result (nth 1 tempList))
                                            )
                                        )
                                           
                                    )
                                    (when (equal indexExplist indexExpb)
                                        (print "SYNTAX_ERROR Expression not recognized  ")
                                         ( return-from parser "error")
                                    )
                                    
                            )
                            (when (and (equal colorError 1)( equal colorAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            ) 
                    )
                )
                (setq discover 1) 
            )
            ; (while EXPB EXPLISTI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "while"))
                (let ( (indexExpb 2)(indexExplist 3)(tempList(list ))(color 0)(check 0)(start 0)(occuring 0)(entered 0) (colorError 1 ) (colorAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) )  
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                            (setq colorError 1 )
                            (when (and  (or (equal  (nth  1 (nth i whole_input))  "KW_TRUE" )(equal  (nth  1 (nth i whole_input))  "KW_FALSE") )(equal check 0))
                                (when (equal  (nth  1 (nth i whole_input))  "KW_TRUE" )
                                    (Setq select t)
                                )
                                (when (equal  (nth  1 (nth i whole_input))  "KW_FALSE" )
                                    (Setq select nil)
                                )
                                (setq colorError 0)
                                (setq hold 1)
                            ) 
                            (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                    (when (equal color 0)
                                        (setq keep i)
                                    )
                                    (setq color ( + color 1 )) 
                                    (setq check 1)
                                    (setq start 1) 
                                    (setq colorError 0 )
                                    (setq colorAfter 0 ) 
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq color (- color 1)) 
                                    (setq colorError 0 )
                                    (setq colorAfter 1 )   
                            )
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                            )  
                            (when  (and (equal color  0)(equal check 1 ))
                                    (Setq check 0)
                                    (setq colorError 0 )
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (when (and (not (typep res 'boolean ) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (typep res 'boolean)
                                        (when (equal res t )
                                            (Setq occuring 1)
                                        
                                        )
                                        (when (equal res nil )
                                            (Setq occuring 0)
                                        
                                        )
                                        (Setq entered 1)

                                    )
                                    (setq num (+ num 1) )
                                    (when (and (equal hold 0)(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (and (equal hold 1)(not(equal num 1)))
                                        (print "SYNTAX_ERROR Expression not recognized  ")
                                         ( return-from parser "error")
                                    )     
                                    (when  (and (typep res 'list) (not (equal res nil))) 
                                        (when (equal hold 0 )
                                            (when (equal occuring 1 )
                                                    (setq result res)
                                            )
                                            (when (equal occuring 0 )
                                                    (setq result nil)       
                                                    
                                            )
                                            (setq indexExplist keep)
                                        )
                                        (when (equal hold 1 )
                                            (when (equal select t)
                                                (setq result res)
                                            )
                                            (when (equal select nil)
                                                (setq result nil)
                                            )
                                        )
                                    )
                                    (when (equal indexExplist indexExpb)
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                            )
                            (when (and (equal colorError 1)( equal colorAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )
                        
                    )
                    result
                )
                (setq discover 1) 
            )
            ; (deffun Id IDLIST EXPLISTI) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_DEFFUN")(equal (nth 1  (nth (+ i 2) whole_input)  ) "IDENTIFIER"))
                (let ( (idList (list ))(color 0)(identifier 0)(check 0)(start 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(expi 0)(j 0))
                        (Setq j 4)
                        (setq identifier (nth 0  (nth (+ i 2) whole_input)  ) )
                        (when  (equal (nth  0 (nth 3 whole_input) ) "(")
                                (loop 
                                    (when  (equal (nth  1 (nth j whole_input) ) "IDENTIFIER") 
                                        (setq idList (append idList (list  (nth  0 (nth j whole_input) ))))

                                    )
                                    (when  (not (equal (nth  1 (nth j whole_input) ) "IDENTIFIER")) 
                                        (print (nth  1 (nth j whole_input)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                        (return-from parser "error")
                                    )
                                    (Setq j (+ j 1))
                                    (when (equal (nth  0 (nth j whole_input) ) ")") (return idList))
                                )
                        )
                        (loop for i from (+ j 1 ) to (-( length whole_input ) 1)
                            do
                                (setq colorError 1 )
                                (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                        (when (equal color 0)
                                            (setq keep i)
                                        )
                                        (setq color ( + color 1 )) 
                                        (setq check 1)
                                        (setq start 1) 
                                        (setq colorError 0)
                                        (setq colorAfter 0)  
                                )
                                (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                        (setq color (- color 1))
                                        (setq colorError 0) 
                                        (setq colorAfter 1)     
                                )
                                (when (equal (nth  0 (nth i whole_input) ) ")") 
                                    (Setq colorError 0)
                                )
                                (when  (and (equal color  0)(equal check 1 ))
                                    (Setq check 0)
                                    (setq colorError 0)
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (when ( not  (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                ) 
                                (when (and (equal colorError 1)( equal colorAfter 1))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )        
                        ) 
                        (Setq result identifier)   
                )
                (setq discover 1) 
            )
            ; (for (Id EXPI EXPI) EXPLISTI)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_FOR")(equal (nth 0  (nth (+ i 2) whole_input)  ) "(")(equal (nth 1  (nth (+ i 3) whole_input)  ) "IDENTIFIER") )
                (let ((ones 0)(i 4)(colorExpi 0)(colorInner 0)(j 0) (tempList(list ))(color 0)(check 0)(start 0)(occuring 0)(entered 0)(counter 0) (colorError 1 ) (colorAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) )                                  
                   (setq color (+ color 1))
                    (loop 
                        (setq colorError 1)
                        (when (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 1)
                                (setq keep i)
                            )
                            (setq j i)
                            (setq colorInner 0)
                            (setq keep j)
                            (loop
                                (when (equal (nth  0 (nth j whole_input) ) "(")
                                      (setq colorInner ( + colorInner 1 ))

                                )      
                                (when  (equal (nth  0 (nth j whole_input) ) ")" )
                                    (setq colorInner (- colorInner 1))
                                )
                                (when (equal colorInner 0 )
                                    (setq colorError 0)
                                    (Setq res (parser ( subseq whole_input keep (+ j 1))))
                                    (when ( not  (integerp res))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                )
                                (setq j (+ j 1))
                                (when (equal colorInner 0) (return j))
                            )   
                            (setq color ( + color 1 )) 
                            (Setq colorError 0)
                            (setq colorAfter 0)
                            
                        )
                        (when (equal (nth  1 (nth i whole_input) ) "VALUE" )
                            (setq colorError 0)
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) ")" )
                            (setq color (- color 1))
                            (setq colorError 0)
                            (setq colorAfter 1)
               
                        )
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )           
                        (setq i (+ i 1))
                        (when (equal color 0) (return i))
                    )
                    (setq j i)
                    (loop for i from j to (-( length whole_input ) 1)
                        do
                            (setq colorError 1 )
                            (when (or (equal (nth  0 (nth i whole_input) ) "(") (equal (nth  0 (nth i whole_input) ) "'("))
                                    (when (equal color 0)
                                        (setq keep i)
                                    )
                                    (setq color ( + color 1 )) 
                                    (setq check 1)
                                    (setq start 1) 
                                    (setq colorError 0)
                                    (setq colorAfter 0)  
                            )
                            (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1) )
                                    (setq color (- color 1))
                                    (setq colorError 0) 
                                    (setq colorAfter 1)     
                            )
                            (when (equal (nth  0 (nth i whole_input) ) ")") 
                                    (Setq colorError 0)
                            )   
                            (when  (and (equal color  0)(equal check 1 ))
                                    (Setq check 0)
                                    (setq colorError 0)
                                    (Setq res (parser ( subseq whole_input keep (+ i 1))))
                                    (setq result res)
                                    (when ( not  (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                            )
                        )
                    res                
                )
                (setq discover 1) 
            )
            ; (load "Id" )
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_LOAD")(equal (nth 1  (nth (+ i 2) whole_input)  ) "OP_OC")(equal (nth 1  (nth (+ i 3) whole_input)  ) "IDENTIFIER")(equal (nth 1  (nth (+ i 4) whole_input)  ) "OP_CC")(equal (nth 1  (nth (+ i 5) whole_input)  ) "OP_CP") )    
                (setq result (nth 0  (nth (+ i 3) whole_input) ))
                result
                (setq discover 1) 
            )
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 0  (nth (+ i 1) whole_input)  ) "less"))
                (let ( (color 0)(logic nil)(check 0) (colorError 1 ) (colorAfter 1)(res nil)(keep 0)(num 0)(value1 nil)(value2 nil))  
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq colorError 1)
                        (when  (and (equal (nth  1 (nth i whole_input) ) "VALUE") (not (equal value1 nil))(equal value2 nil)(equal check 0))
                            (when (equal (nth  1 (nth i whole_input) ) "VALUE")
                                (setq value2 (parse-integer (nth  0 (nth i whole_input) )))
                                (setq colorError 0 )
                            ) 
                        )
                        (when  (and (equal (nth  1 (nth i whole_input) ) "VALUE")(equal value1 nil)(equal check 0) )
                            (when (equal (nth  1 (nth i whole_input) ) "VALUE")
                                (setq value1 (parse-integer (nth  0 (nth i whole_input) )))
                                (setq colorError 0 )
                            ) 
                        )
                        (when   (equal (nth  0 (nth i whole_input) ) "(")
                            (when (equal color 0)
                                (setq keep i)
                            )
                            (setq color ( + color 1 )) 
                            (setq check 1)
                            (setq colorError 0 )
                            (setq colorAfter 0 )
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i whole_input) ) ")" )(equal check 1))
                            (setq color (- color 1))
                            (setq colorError 0 )
                            (setq colorAfter 0 )
                            
                        ) 
                        (when (equal (nth  0 (nth i whole_input) ) ")") 
                                (Setq colorError 0)
                        )
                        (when  (and (not (equal value1 nil))(not (equal value2 nil)))
                            (when (and (not (equal (type-of value1 )(type-of value2)))(not (equal (integerp value1 )(integerp value2))))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )
                            (setq logic (< value1 value2))
                        ) 
                        (when  (and (equal color  0)(equal check 1 ))
                            (Setq check 0)
                            (setq colorError 0)
                            (setq res  (parser ( subseq whole_input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when   (and (not(equal value1 nil))(equal value2 nil))
                                   (setq value2  res )
                                   (when (or (not (typep value2 'NULL)) (not (typep value1 'NULL)))
                                        (when (and (not (equal (type-of value1 )(type-of value2)))(not (equal (integerp value1 )(integerp value2))))
                                            (print "SYNTAX_ERROR Expression not recognized ")
                                             ( return-from parser "error")
                                        )
                                   )       
                                )
                                (when   (equal value1 nil)
                                    (setq value1 res)
                                )
                                
                            )
                            (when (not(typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")     
                            )      
                        )
                       
                        (when (and (equal colorError 1)( equal colorAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                            ( return-from parser "error")
                        )
                        (setq result logic)     
                    )
                ) 
                (setq discover 1)    
            
            )
            ; ( disp ) 
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_DISP")) 
                (let ( (i 0)(lst (list ))) 
                    (loop for i from 2 to (-( length whole_input ) 1)
                        do
                        (setq lst (concatenate 'string lst  " " (nth  0 (nth i whole_input) ) ))


                    )
                    (setq result lst)
                    (setq discover 1)  
                ) 
                      
            )
            ; (exit)
            (when (and (equal (nth  0 (nth i whole_input) ) "(") (equal (nth 1  (nth (+ i 1) whole_input)  ) "KW_EXIT")(equal (nth 0  (nth (+ i 2) whole_input)  ) ")") ) 
                (print "exit is entered, Program is terminating.... GoodBye")
                (setq discover 1) 
                (return-from parser t)       
            )
            ;Doing syntax analiysis for comment
            (when  (equal (nth  1 (nth i whole_input) ) "COMMENT")
                (setq discover 1)
                (Setq result t)
            )
            (when (equal discover 0)
                (print  (nth i whole_input)  )
                (print "SYNTAX_ERROR Expression not recognized ")
                 ( return-from parser "error")
            )
            (return-from parser result)   
        )))

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

;In this section, the user can read from the file or enter values directly into the terminal.
(defun gppinterpreter (&optional fileName)
	(write-string "-> ")
	
    (when  (equal fileName nil) ;If file name is empty
       	;After the g++ text, the user can write any expression user wants.
        (write-line "g++") 
        	(loop 
				;Read line from interpreter.
                (setq interpreter ( read-line ))  
                ; print lex 
                (setq lex (lexer interpreter )) 
                
                ;Doing lexical analysis.
                (setq res (parser lex))
                (when (not (equal res "error" ))
                    (print "SYNTAX OK.")(terpri)
                        (format t "Result :~a " res) 
                )
                (terpri)
		    (when (equal interpreter "(exit)")  (return 0)))

    )
    ;Load file and make lexical analiysis.
    (when  (not (equal fileName nil)) 
       
        (Setq i 0)
        ;for writing filename on interpreter.
		(loop 
			(setq i  (+ i 1))
			(when (equal i (-(length fileName ) 4)) (return ( setq name (subseq  fileName 0 i   )))) 
		)

		; g++ filename.g++ on interpreter.
        (format t "g++ ~a.g++" name)(terpri) 
        (read_from_file fileName )
    )
)

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

(write-line "Testing with the input file.")
( gppinterpreter "inputFile.g++" )
(terpri)

;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;
;----------------------------------------------------------------------------------------------------------------;

(write-line "Testing with the expression.")(terpri)
( gppinterpreter )
